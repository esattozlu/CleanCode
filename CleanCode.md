# CleanCode

##Chapter 1: Clean Code
### There Will Be Code
Code is really the language in which we ultimately express the require- ments. We may create languages that are closer to the requirements. We may create tools that help us parse and assemble those requirements into formal structures. But we will never eliminate necessary precision—so there will always be code.

### Bad Code
Bad code slows things down and drags the project into a dead end.

### The Total Cost of Owning a Mess
Every addition or modification to the system requires that the tangles, twists, and knots be “understood” so that more tangles, twists, and knots can be added. Over time the mess becomes so big and so deep and so tall, they can not clean it up. As the mess builds, the productivity of the team continues to decrease, asymptotically approaching zero. 
  
### Schools of Thought

### We Are Authors

### The Boy Scout Rule

### Prequel and Principles

## Chapter 2: Meaningful Names
### Use Intention-Revealing Names
### Avoid Disinformation
### Make Meaningful Distinctions 
### Use Pronounceable Names
### Use Searchable Names
### Avoid Encodings
### Avoid Mental Mapping 
### Class Names
### Method Names
### Don’t Be Cute
### Pick One Word per Concept
### Don’t Pun
### Use Solution Domain Names
### Use Problem Domain Names
### Add Meaningful Context
### Don’t Add Gratuitous Context

## Chapter 3: Functions
### Small!
### Do One Thing
### One Level of Abstraction per Function
### Switch Statements
### Use Descriptive Names
### Function Arguments
### Have No Side Effects
### Command Query Separation
### Prefer Exceptions to Returning Error Codes
### Don’t Repeat Yourself 
### Structured Programming
### How Do You Write Functions Like This?

## Chapter 4: Comments
### Comments Do Not Make Up for Bad Code
### Explain Yourself in Code
### Good Comments
### Bad Comments

## Chapter 5: Formatting
### The Purpose of Formatting
### Vertical Formatting
### Horizontal Formatting
### Team Rules
### Uncle Bob’s Formatting Rules

## Chapter 6: Objects and Data Structures
### Data Abstraction
### Data/Object Anti-Symmetry
### The Law of Demeter
### Data Transfer Objects

## Chapter 7: Error Handling
### Use Exceptions Rather Than Return Codes
### Write Your Try-Catch-Finally Statement First
### Use Unchecked Exceptions
### Provide Context with Exceptions
### Define Exception Classes in Terms of a Caller’s Needs
### Define the Normal Flow
### Don’t Return Null
### Don’t Pass Null

## Chapter 8: Boundaries
### Using Third-Party Code
### Exploring and Learning Boundaries
### Learning log4j
### Learning Tests Are Better Than Free
### Using Code That Does Not Yet Exist 
### Clean Boundaries

## Chapter 9: Unit Tests
### The Three Laws of TDD
### Keeping Tests Clean
### Clean Tests
### One Assert per Test
### F.I.R.S.T.

## Chapter 10: Classes
### Class Organization
### Classes Should Be Small!
### Organizing for Change

## Chapter 11: Systems
### How Would You Build a City?
### Separate Constructing a System from Using It
### Scaling Up
### Java Proxies
### Pure Java AOP Frameworks
### AspectJ Aspects
### Test Drive the System Architecture
### Optimize Decision Making
### Use Standards Wisely, When They Add Demonstrable Value
### Systems Need Domain-Specific Languages

## Chapter 12: Emergence
### Getting Clean via Emergent Design
### Simple Design Rule 1: Runs All the Tests
### Simple Design Rules 2–4: Refactoring
### No Duplication
### Expressive
### Minimal Classes and Methods
